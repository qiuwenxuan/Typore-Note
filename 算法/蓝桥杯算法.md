![image-20220315080713376](C:\Users\17377\AppData\Roaming\Typora\typora-user-images\image-20220315080713376.png)

```
加：add
减：subtract
乘：multiply
除：divide
取余：mod
求最大值：max
求最小值：min
求最大公因数：gcd
求最小公倍数：lcm
Math方法：
	1.求最值
		Math.max(a,b);
		Math.min(a,b);
	2.求平方根,立方根
		Math.sqrt(a)； //平方根
	 	Math.cbrt(b);     //立方根
	3.求绝对值
		Math.abs(a)；
	4.求幂
		Math.pow(a, b)；  a^b
	5.取整
        Math.ceil(x)；向上取整
        Math.floor(x)；向下取整
        Math.round(x); 四舍五入取整
	6.生成随机数
		Math.random()； 生成一个[0,1)之间的double类型的伪随机数
	7.三角函数
        Math.cos(double a) 余弦
        Math.acos(double a) 反余弦
        Math.sin(double a) 正弦值
        Math.asin(double a) 反正弦值
        Math.tan(double a) 正切值
        Math.atan(double a) 反正切
     
```

## 1.算法大全

### 算法1_枚举

1.例://编写一个格式,程序输入一个数字n,使得a,b,c,d <= n形如a^3 = b^3+c^3+d^3 其中a,b,c,d均大于1且b<=c<=d.

```java
package day1125;

import java.util.Scanner;
//编写一个格式,程序输入一个数字n,使得a,b,c,d <= n形如a^3 = b^3+c^3+d^3 其中a,b,c,d均大于1且b<=c<=d.
public class Demo01meiju {
	public static void main(String[] args) {
		Scanner scan = new Scanner(System.in);
		System.out.println("请输入数字n:");
		int n = scan.nextInt();
		for(int a = 2; a <= n; a++) {
			for(int b = 2; b < a; b++) {
				for(int c = b; c < a; c++) {
					for(int d = c; d < a; d++) {
						if(a*a*a == b*b*b + c*c*c + d*d*d) {
							System.out.println("Cube = "+a+" Tripe = "+b+" "+c+" "+d);
						}
					}
				}
			}
		}
	}
}

```

2.枚举法求最大公因数和最小公倍数

```java
public static int gcd2(int a, int b) {//最大公因数 枚举法
		int min = Math.min(a, b);
		int result = 0;
		for(int i = 1; i <= min; i++) {
			if(a%i==0 && b%i==0) {
				result = i;
			}
		}
		return result;
	}

	public static int lcm2(int a,int b){//最小公倍数 枚举法
        int temp=0;
        if(a<=0||b==0){
            return -1;
        }
        temp=Math.max(a,b);
        while(temp%a!=0||temp%b!=0){
            temp++;
        }
        return temp;
    }
```



### 算法2_递归

```
1.递归可以解决的问题
    1）各种数学问题，如8皇后问题，汉诺塔，阶层问题，迷宫问题，球和篮子的问题
    2）各种算法中也会用到递归，比如快排，归并排序，二分查找，分治算法等
    3）将用栈解决的问题-->递归代码比较简洁
2.递归需要遵守的重要规则    
    1）执行一个方法时就会创建出一个受保护的独立的栈空间
    2）方法的局部变量是独立的，不会相互影响，比如n变量
    3）如果方法当中使用的是引用变量（比如数组），就会共享该引用类型的数据
    4）递归必须向退出递归的条件逼近，否则就是无限递归，出现StackOverflowError（栈越界）
    5）如果一个方法执行完毕，或者遇到return，就会返回给调用该方法的目标，且该方法也就执行完毕
    
    递归方法缓存的数据都储存在栈里面,且最后开辟的栈最开始运行.

2.递归的步骤:
	1.找重复
	2.找变化
	3.找边界:出口(限制条件):一般设置成与迭代条件相反的条件

```

1.递归调用机制

![image-20220311231703906](C:\Users\17377\AppData\Roaming\Typora\typora-user-images\image-20220311231703906.png)

2.递归算法：迷宫问题

![image-20220312153645748](C:\Users\17377\AppData\Roaming\Typora\typora-user-images\image-20220312153645748.png)

![image-20220312154442895](C:\Users\17377\AppData\Roaming\Typora\typora-user-images\image-20220312154442895.png)

1)求n的阶乘

```java
	public static int Factorial(int n) {
		if(n == 0) {
			return 1;
		}
		return n*Factorial(n-1);
	}
```

2)打印数字

```java
public static void f1(int i,int j){//变化的量:i必须作为参数
	if(i>=j)
	return;//程序边界
	System.out.println(i);
	f1(i+1,j);//重复条件
}
```

3)翻转字符串

![image-20220313160238204](C:\Users\17377\AppData\Roaming\Typora\typora-user-images\image-20220313160238204.png)

翻转字符串还有一种方法：迭代方法（与递归作对比）

![image-20220313151839470](C:\Users\17377\AppData\Roaming\Typora\typora-user-images\image-20220313151839470.png)

4)用递归实现斐波那契数列 

1、1、2、3、5、8、13、21、... F(1)=1, f(2)=1 ... F(N)=F(N-1)+F(N-2)

```java
public static int fiblibSum(int n){
		if (n==1 || n==2) 
			return 1;
		else
			return fiblibSum(n-1)+fiblibSum(n-2);
	}
```

即先算最后一个结果return 1; 再逐个把前面的结果fiblibSum(n-1)+fiblibSum(n-2)求出来.

5)求最大公因数

```java
public static int gcd(int a,int b){
	if(b==0)
	return a;
	gcd(b,a%b);
}
```

6）汉诺塔问题

```
解题思路：
通过分析以上 3 种情况的移动思路，可以总结出一个规律：对于 n 个圆盘的汉诺塔问题，移动圆盘的过程是：
将起始柱上的 n-1 个圆盘移动到辅助柱上；
将起始柱上遗留的 1 个圆盘移动到目标柱上；
将辅助柱上的所有圆盘移动到目标柱上。

由此，n 个圆盘的汉诺塔问题就简化成了 n-1 个圆盘的汉诺塔问题。按照同样的思路，n-1 个圆盘的汉诺塔问题还可以继续简化，直至简化为移动 3 个甚至更少圆盘的汉诺塔问题。
```

![image-20220315100426891](C:\Users\17377\AppData\Roaming\Typora\typora-user-images\image-20220315100426891.png)

```java
package lqbday1129;

public class HannuoTower {
	public static void main(String[] args) {
		printHannuoTower(3,"A","B","C");
	}
	static void printHannuoTower(int N, String from, String to, String help) {
		if(N==1) {
			System.out.println("move "+N+" from "+from+" to "+ to);
			return;
		}
		printHannuoTower(N-1,from,help,to);
		System.out.println("move "+N+" from "+from+" to "+to);
		printHannuoTower(N-1,help,to,from);	
		
	}
}
运行结果:
	move 1 from A to B
    move 2 from A to C
    move 1 from B to C
    move 3 from A to B
    move 1 from C to A
    move 2 from C to B
    move 1 from A to B

```

7.八皇后问题

![img](https://img-blog.csdnimg.cn/20181101215219446.png)

```java
public class Queue8 {

	//定义一个max表示共有多少个皇后
	int max = 8;
	//定义数组array, 保存皇后放置位置的结果,比如 arr = {0 , 4, 7, 5, 2, 6, 1, 3}
	int[] array = new int[max];
	static int count = 0;
	static int judgeCount = 0;
	public static void main(String[] args) {
		//测试一把 ， 8皇后是否正确
		Queue8 queue8 = new Queue8();
		queue8.check(0);
		System.out.printf("一共有%d解法", count);
		System.out.printf("一共判断冲突的次数%d次", judgeCount); // 1.5w

	}



	//编写一个方法，放置第n个皇后
	//特别注意： check 是 每一次递归时，进入到check中都有  for(int i = 0; i < max; i++)，因此会有回溯
	private void check(int n) {
		if(n == max) {  //n = 8 , 其实8个皇后就既然放好
			print();
			return;
		}

		//依次放入皇后，并判断是否冲突
		for(int i = 0; i < max; i++) {
			//先把当前这个皇后 n , 放到该行的第1列
			array[n] = i;
			//判断当放置第n个皇后到i列时，是否冲突
			if(judge(n)) { // 不冲突
				//接着放n+1个皇后,即开始递归
				check(n+1); //
			}
			//如果冲突，就继续执行 array[n] = i; 即将第n个皇后，放置在本行得 后移的一个位置
		}
	}

	//查看当我们放置第n个皇后, 就去检测该皇后是否和前面已经摆放的皇后冲突
	/**
	 *
	 * @param n 表示第n个皇后
	 * @return
	 */
	private boolean judge(int n) {
		judgeCount++;
		for(int i = 0; i < n; i++) {
			// 说明
			//1. array[i] == array[n]  表示判断 第n个皇后是否和前面的n-1个皇后在同一列
			//2. Math.abs(n-i) == Math.abs(array[n] - array[i]) 表示判断第n个皇后是否和第i皇后是否在同一斜线
			// n = 1  放置第 2列 1 n = 1 array[1] = 1
			// Math.abs(1-0) == 1  Math.abs(array[n] - array[i]) = Math.abs(1-0) = 1
			//3. 判断是否在同一行, 没有必要，n 每次都在递增
			if(array[i] == array[n] || Math.abs(n-i) == Math.abs(array[n] - array[i]) ) {
				return false;
			}
		}
		return true;
	}

	//写一个方法，可以将皇后摆放的位置输出
	private void print() {
		count++;
		for (int i = 0; i < array.length; i++) {
			System.out.print(array[i] + " ");
		}
		System.out.println();
	}

}
```

### 算法3_分治算法

```
分治算法解决问题的过程需要经历 3 个阶段，分别是：
分：将整个问题划分成多个相对独立、涉及数据量更少的小问题，有些小问题还可以划分成很多更小的问题，直至每个问题都不可再分；
治：逐个解决所有的小问题；
合并：将所有小问题的解决方案合并到一起，找到解决整个问题的方案。
```

1.分治算法求数组最大值

![img](http://c.biancheng.net/uploads/allimg/210820/2-210R0100636353.gif)

```java
public class Demo {
    public static int get_max(int [] arr,int left,int right) {
        //如果数组不存在或者数组内没有元素
        if (arr == null || arr.length == 0) {
            return -1;
        }
        //如果查找范围中仅有 2 个数字，则直接比较即可
        if(right - left <=1) {
            if(arr[left] >= arr[right]) {
                return arr[left];
            }
            return arr[right];
        }
        //等量划分成 2 个区域
        int middle = (right-left)/2 + left;
        int max_left = get_max(arr,left,middle);
        int max_right = get_max(arr,middle+1,right);
        if(max_left >= max_right) {
            return max_left;
        }else {
            return max_right;
        }
    }
    public static void main(String[] args) {
        int [] arr = new int[] { 3,7,2,1 };
        int max = get_max(arr,0,3);
        System.out.println("最大值："+max);
    }
}
```

![image-20220315085331092](C:\Users\17377\AppData\Roaming\Typora\typora-user-images\image-20220315085331092.png)

### 算法4_贪心算法

### 算法5_深度优先和广度优先搜索

深度优先搜索（DFS）是一种思想，而递归是深度优先搜索这种思想在算法当中的实现（菲波那切数列，求阶乘递归都是深搜）

```
1.深度优先搜索（DFS）：
dfs就是我们常说的深度优先搜索，它的思路就是：我们每一次搜索到一个点的时候，如果这个点不符合条件，那么就return，返回到上一层（就是常说的回朔），如果这个点符合条件，就一直搜索下去，直到没有点可以搜索。
不过要记得，走过的点一定要记录下来，不然整个递归过程就会无穷无尽。
```

![image-20220318142557512](C:\Users\17377\AppData\Roaming\Typora\typora-user-images\image-20220318142557512.png)

```java
void dfs(int deep)
{
    int x=deep/n,y=deep%n;
    if(符合某种要求||已经不能在搜了)
    {
        做一些操作；
        return ;
    }
    if(符合某种条件且有地方可以继续搜索的)//这里可能会有多种条件，可能要循环什么的
    {
        a[x][y]=&#39;x&#39;;//可能要改变条件，这个是瞎写的
            dfs(deep+1,sum+1);//搜索下一层
        a[x][y]=&#39;.&#39;;//可能要改回条件，有些可能不用改比如搜地图上有多少块连续的东西
    }
}
```

广度优先搜索（DFS）

```
bfs就是我们常说的广度优先搜索或宽度优先搜索，它的思路就是：我们每一次搜索到一个点的时候，如果这个点不符合条件，那么搜索同一层中符合条件的点，再把这一层中符合要求的点一一拓展，按照上述形式搜索下去。
和dfs一样，走过的点一定要记录下来，不然整个递归过程就会无穷无尽。
```

![image-20220318142802365](C:\Users\17377\AppData\Roaming\Typora\typora-user-images\image-20220318142802365.png)

```java
void bfs1(node p)
{
    node t,tt;
    v.push(p);
    while(!v.empty())
    {
        t=v.front();//取出最前面的
        v.pop();//删除
        if(找到符合条件的)
        {
            做记录；
            while(!v.empty()) v.pop();//如果后面还需要用，随手清空队列
            return;
        }
        visit[t.x][t.y]=1;//走过的进行标记，以免重复
        rep(i,0,4)//做多次查找
        {
            tt=t;
            tt.x+=dir[i][0];tt.y+=dir[i][1];//这里的例子是向上下左右查找的
            if(如果这个位置符合条件)
            {
                tt.bits++;//步数加一
                v.push(tt); //把它推入队列，在后面的时候就可以用了
            }
        }
    }
}
```

### 算法6_二分法查找

```
二分法查找思路分析：
1.首先确认该数组的中间下标
	mid= （left+right）/2
2.然后让需要查找的数findVal和arr[mid]比较
	2.1 findVal>arr[mid],说明你要查找的数在arr[mid]的右边，因此需要递归向右查找
	2.2 findVal<arr[mid],说明你要查找的数在arr[mid]左边，需要递归向左查找
	2.3 findVal==arr[mid],说明找到，直接返回

2.结束递归
1.找到就结束递归
2.递归完整个数组，仍然没有找到findVal,也需要结束递归 当left>right，就需要退出
```

1.最直接的二分法

![image-20220403155718872](C:\Users\17377\AppData\Roaming\Typora\typora-user-images\image-20220403155718872.png)

2.二分法查找多个相同元素

![image-20220403215625037](C:\Users\17377\AppData\Roaming\Typora\typora-user-images\image-20220403215625037.png)

```java
package tiankong;

import java.util.ArrayList;

public class Main12 {
	public static void main(String[] args) {
		int[] arr = { 1, 2, 2, 2, 2, 3, 4, 5 };
//		int index = erFen(arr, 0, arr.length, 110);
		ArrayList<Integer> index2 = erFen2(arr, 0, arr.length - 1, 2);
		index2.sort(null);//将集合元素进行排序
//		System.out.println(index);
		System.out.println(index2);
	}

	private static int erFen(int[] arr, int left, int right, int findVal) {
		int mid = (left + right) / 2;
		if (left > right) {
			return -1;
		}
		if (arr[mid] < findVal) {
			return erFen(arr, mid + 1, right, findVal);
		} else if (arr[mid] > findVal) {
			return erFen(arr, left, mid - 1, findVal);
		} else {
			return mid;
		}
	}

	private static ArrayList<Integer> erFen2(int[] arr, int left, int right, int findVal) {
		ArrayList<Integer> list = new ArrayList<Integer>();
		int mid = (left + right) / 2;
		if (left > right) {
			return new ArrayList<Integer>();
		}
		if (arr[mid] < findVal) {
			return erFen2(arr, mid + 1, right, findVal);
		} else if (arr[mid] > findVal) {
			return erFen2(arr, left, mid - 1, findVal);
		} else {// 添加左边相同的元素
			int temp = mid - 1;

			while (true) {
				if (temp < 0 || arr[temp] != findVal) {
					break;
				}
				list.add(temp);
				temp -= 1;
			}
			list.add(mid);// 添加中间的元素
			temp = mid + 1;// 添加右边的元素
			while (true) {
				if (temp > arr.length-1 || arr[temp] != findVal) {
					break;
				}
				list.add(temp);
				temp += 1;
			}
			return list;
		}
	}
}
输出：
    [1, 2, 3, 4]
```

#### 1.在有序的序列中查找n是否存在,若存在返回数组下标

![image-20220318152112645](C:\Users\17377\AppData\Roaming\Typora\typora-user-images\image-20220318152112645.png)

#### 2.二分查找一个大于等于n的最小值

```java
package demo;

public class Erfenfa {
//最小的大于数下标1,3,4 n=2,输出3的下标 我们要找mid大于等于n的
	public static void main(String[] args) {
		int[] arr = new int[] {11,22,33,44,55};
		System.out.println(search(arr, 22));
	}
	public static int search(int[] arr,int n) {
		int left = 0;
		int right = arr.length-1;
		int result = 0;
		while(left<right) {
			int mid = (left+right)/2;
			if(arr[mid]>n) {
				right = mid;
			}else {
				left = mid+1;
			}
			result=left;
		}
		return result;
	}

}

```

#### 3.二分查找一个小于等于x的最大值

```java
package demo;

public class Erfenfa {
	//二分查找一个小于等于n的最大值1.3.5.7 2=1
	public static void main(String[] args) {
		int[] arr = new int[] {11,22,33,44,55};
		System.out.println(search(arr, 45));
	}
	public static int search(int[] arr,int n) {
		int left = 0;
		int right = arr.length-1;
		int result = 0;
		while(left<right) {
			int mid = (left+right+1)/2;
			if(arr[mid]>n) {
				right = mid-1;//由于找的是小于等于n的最小值，因此当mid>n时，需要把mid都一并抛弃掉
			}else {
				left=mid;
			}
			result = left;
		}
		return result;
	}
}
在以上的代码中， mid = (l + r + 1) / 2
为什么呢？ 因为(l+r)/2的结果会被下取整，当l = 0， r = 1时，mid = 0
如果此时arr[0]正好等于x的话， l 就会等于0， 那么因为l和r并没有被更新，
下一次循环mid还是0， 所以就会一直这样循环下去。为了避免死循环，需要特殊处理一下边界问题，也就是（l + r + 1) / 2。这样得到的mid就会不同了。
```

二分法例题：

![在这里插入图片描述](https://img-blog.csdnimg.cn/20200211205435635.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0dEX09ORQ==,size_16,color_FFFFFF,t_70)

```java
package demo;

import java.util.ArrayList;
import java.util.Iterator;
import java.util.Scanner;

public class Demo01 {

	public static void main(String[] args) {
		Scanner scan = new Scanner(System.in);
		int a = scan.nextInt();
		int b = scan.nextInt();
		int[] arr = new int[a];
		int[] arr1 = new int[10000];
		for (int i = 0; i < arr.length; i++) {
			arr[i] = scan.nextInt();
		}
		for (int i = 0; i < b; i++) {
			int n = scan.nextInt();
			arr1[i] = n;
		}
		for (int i = 0; i < arr1.length; i++) {
			System.out.print(arrStart(arr,arr1[i]));
			System.out.print(arrEnd(arr,arr1[i]));
		}
		
	}
	public static int arrStart(int[] arr,int n) {//小于等于的最大值
		int left = 0;
		int right = arr.length-1;
		int result = 0;
		while(left<right) {
			int mid = (left+right+1)/2;
			if(arr[mid]>n) {
				right = mid-1;
			}else if(arr[mid]<n){
				left = mid;
			}else {
				return -1;
			}
			result = left;
		}
		return result;
	}
	public static int arrEnd(int[] arr,int n) {//大于等于最小值
		int left = 0;
		int right = arr.length-1;
		int result = 0;
		while(left<right) {
			int mid = (left+right)/2;
			if(arr[mid]>n) {
				right = mid;
			}else if(arr[mid]<n){
				left = mid+1;
			}else {
				return -1;
			}
			result = left;
		}
		return result;
	}
}

```

### 算法7_冒泡排序

1.算法思想：核心代码

```java
//注意事项：
for (int i = 0; i < n - 1; i++) {//确定循环次数，每循环一次都有一个数排序好，
            for (int j = 0; j < n - 1 - i; j++) {//循环遍历未排序好的数组，每次i循环一次，j循环次数-i
                if (a[j] > a[j + 1]) swap(j, j + 1);//注意事项：因为a[j]与a[j+1]做对比，因此我们循环次数i和j条件都要-1，避免越界
            }
        }
```

用冒泡排序算法对 {14, 33, 27, 35, 10} 完成升序排序的 Java 程序：

```java
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;

public class Main03 {
    //冒泡排序
    static BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
    static int[] a;

    public static void main(String[] args) throws IOException {
        int n = Integer.parseInt(br.readLine());
        String[] ss = br.readLine().split(" ");
        a = new int[n];
        for (int i = 0; i < n; i++) {
            a[i] = Integer.parseInt(ss[i]);
        }
        for (int i = 0; i < n - 1; i++) {
            for (int j = 0; j < n - 1 - i; j++) {
                if (a[j] > a[j + 1]) swap(j, j + 1);
            }
        }
        for (int i = 0; i < n; i++) {
            System.out.print(a[i]);
        }
    }

    private static void swap(int j, int i) {
        int temp = 0;
        temp = a[i];
        a[i] = a[j];
        a[j] = temp;
    }
}

```



### 算法8_插入排序

### 算法9_动态规划

```
动态规划算法介绍：
1）动态规划算法的核心思想就是将大问题划分为小问题来解决，从而进一步获取最优解
2）动态规划算法与分治算法类似，基本思想就是将待解决的问题分为若干个子问题，先求解子问题从而进一步根据这些子问题得到问题的解
3）与分治算法不同的是，适合用动态规划求解的问题经分解得到的子问题往往都不是相互独立的。（即下一个子阶段的求解是建立在上一个子阶段的解的基础上，进行进一步的求解）
4）动态规划可以通过填表的方式来逐步推进，得到最优解
```

```
动态规划算法实践-01背包问题（所装物品不能重复）
```

![image-20220329150837971](C:\Users\17377\AppData\Roaming\Typora\typora-user-images\image-20220329150837971.png)

```
背包问题装包策略：
（1）v[i][0]=v[0][j]=0;//表示填入表第一行第一列都是0
（2）当w[i]>j时：v[i][j]=max{v[i-1][j],v[i]+v[i-1][j-w[i]]} ;//当准备加入的新增的商品的容量小于等于当前背包的容量
//装入的方式：
v[i-1][j]:就是上一个单元格的装入的最大值
v[i]:表示当前商品的价值
v[i-1][j-w[i]]:装入i-1商品，到剩余空间j-w[i]的最大值
当j>=w[i]时：v[i][j]=max{v[i-1][j],v[i]+v[i-1][j-w[i]]};
```

![image-20220329151806243](C:\Users\17377\AppData\Roaming\Typora\typora-user-images\image-20220329151806243.png)

代码实现：

```java
package Algorithm.DynamicProgramming;

/**
 * 动态规划解决背包问题
 */
public class KnapsackProblem {
    public static void main(String[] args) {
        int[] w = {1,4,3};//物品重量
        int[] val = {1500,3000,2000};//物品价值
        int m = 4;//背包容量
        int n = val.length;//物品个数

        //创建二维数组，v[i][j]表示在前i个物品中能够装入容量为j的背包中的最大价值
        int[][] v = new int[n+1][m+1];
        //记录放入商品的情况
        int[][] path = new int[n+1][m+1];

        //初始化 v[i][0]=v[0][j]=0
        for (int i = 0; i < v.length; i++) {
            v[i][0] = 0;
        }
        for (int i = 0; i < v[0].length; i++) {
            v[0][i] = 0;
        }

        //动态规划
        for (int i = 1; i < v.length; i++) {//不处理第一行 i 是从 1 开始的
            for (int j = 1; j < v[0].length; j++) {//不处理第一列 j 是从 1 开始的
                if (w[i-1] > j){ // 因为我们程序i是从1开始的，因此原来公式中的w[i]修改成 w[i-1], v[i]修改成val[i-1]
                    v[i][j]=v[i-1][j];
                }else {
                    //v[i][j]=Math.max(v[i-1][j], val[i-1]+v[i-1][j-w[i-1]]);
                    if (v[i-1][j] < val[i-1]+v[i-1][j-w[i-1]]){
                        v[i][j] = val[i-1]+v[i-1][j-w[i-1]];
                        //记录最优情况
                        path[i][j] = 1;
                    }else {
                        v[i][j]=v[i-1][j];
                    }
                }
            }
        }

        show(v);

        //输出结果
        int i = path.length -1;
        int j = path[0].length - 1;
        while ( i > 0 && j > 0){//从最后开始找
            if (path[i][j] == 1){
                System.out.printf("第%d个商品放入背包\n", i);
                j -= w[i-1]; //背包剩余多少容量
            }
            i--;
        }
    }

    /**
     * 打印矩阵
     * @param v 目标矩阵
     */
    public static void show(int[][] v) {
        for (int i = 0; i < v.length; i++) {
            for (int j = 0; j < v[0].length; j++) {
                System.out.print(v[i][j] + " ");
            }
            System.out.println();
        }
    }
}


```



### 算法10_KMP算法

KMP算法和暴力匹配主要用于字符串的匹配，但前者的时间复杂度比后者要低，KMP算法对比于暴力匹配相当于引入了一个部分匹配值的概念跳过了一部分的算法回溯从而降低时间复杂度

#### 1.暴力匹配

![image-20220327095608466](C:\Users\17377\AppData\Roaming\Typora\typora-user-images\image-20220327095608466.png)

```java
package day0327;

public class Text01 {
	public static void main(String[] args) {
		//测试暴力匹配算法
		String str1 = "硅硅谷 尚硅谷你尚硅 尚硅谷你尚硅谷你尚硅你好";
		String str2 = "尚硅谷你尚硅你";
		int index = violenceMath(str1, str2);
		System.out.printf("index=%d",index);
	
	}

	// 暴力算法实现
	public static int violenceMath(String str1, String str2) {
		char[] s1 = str1.toCharArray();
		char[] s2 = str2.toCharArray();

		int s1len = s1.length;
		int s2len = s2.length;

		int i = 0;// i索引指向s1
		int j = 0;// j索引指向s2
		while (i < s1len && j < s2len) {// 保证匹配不越界

			if (s1[i] == s2[j]) {// 匹配成功
				i++;
				j++;
			} else {// 没有匹配成功
				// 如果匹配失败（即Str1[i]!=str2[j]）,令i = i-(j-1),j=0。
				i = i - (j - 1);
				j = 0;
			}
		}
		//判断是否匹配成功
		if (j==s2len) {
			return i -j;
		}else {
			return -1;
		}
		
	}
}

```

```
结果：index=15
```

![image-20220408231048325](C:\Users\17377\AppData\Roaming\Typora\typora-user-images\image-20220408231048325.png)

#### 2.KMP算法

部分匹配表：

例如：字符串：bread

前缀：b,br,bre,brea 除了主字符串最后一个字符所构成的字符串集合

后缀：read,ead,ad,d 除了主字符串最前面的字符所构成的字符串集合

而部分匹配值就是“前缀”和“后缀”的最长的共有元素的长度

![image-20220328211803810](C:\Users\17377\AppData\Roaming\Typora\typora-user-images\image-20220328211803810.png)

![image-20220328211811519](C:\Users\17377\AppData\Roaming\Typora\typora-user-images\image-20220328211811519.png)

![image-20220328212012924](C:\Users\17377\AppData\Roaming\Typora\typora-user-images\image-20220328212012924.png)

```
1)KMP是一个解决模式串在文本串是否出现过，如果出现过，最早出现的位置的经典算法
2) Knuth-Morris-Pratt 字符串查找算法，简称为“KMP算法”，常用于在一个文本串S内查找一个模式串Р的出现位置，这个算法由DonaldKnuth、Vaughan Pratt、James H.Momis三人于1977年联合发表，故取这3人的姓氏命名此算法.
3)KMP方法算法就利用之前判断过信息，通过一个next数组，保存模式串中前后最长公共子序列的长度，每次回溯时，通过next数组找到，前面匹配过的位置，省去了大量的计算时间
```

```
有一个字符串 Str1 = “BBC ABCDAB ABCDABCDABDE”，判断，里面是否包含另一个字符串 Str2 =“ABCDABD”
```

```java
package Algorithm.KMP;

import java.util.Arrays;

/**
 * KMP算法
 */
public class KMP {
    public static void main(String[] args) {
        String str1 = "BBC ABCDAB ABCDABCDABDE";
        String str2 = "ABCDABD";
        int[] next = getKmpNext(str2);
        System.out.println(Arrays.toString(next));

        int kmpSearch = kmpSearch(str1, str2, next);
        System.out.println(kmpSearch);
    }

    /**
     * KMP算法
     * @param str1 源字符串
     * @param str2 子串
     * @param next 子串匹配表
     * @return 返回第一个匹配的位置，反之返回-1
     */
    public static int kmpSearch(String str1,String str2, int[] next){
        for (int i = 0,j = 0; i < str1.length(); i++) {
            //当 dest.charAt(i) != dest.charAt(j) ，我们需要从 next[j-1]获取新的 j
            //直到我们发现有dest.charAt(i) == dest.charAt(j)成立才退出
            while (j> 0 && str1.charAt(i) != str2.charAt(j)){
                j = next[j-1];
            }
            if (str1.charAt(i) == str2.charAt(j)){
                j++;
            }
            if (j == str2.length()){
                return i-j+1;
            }
        }
        return -1;
    }

    /**
     * 获取一个子串的部分匹配值表
     * @param dest 子串
     * @return 部分匹配值表
     */
    public static int[] getKmpNext(String dest){
        int[] next = new int[dest.length()];//创建next数组
        next[0] = 0;//如果字符串的长度为1，部分匹配值就是0
        for (int i = 1, j =0 ; i < dest.length(); i++) {
            //当 dest.charAt(i) != dest.charAt(j) ，我们需要从 next[j-1]获取新的j
            //直到我们发现有dest.charAt(i) == dest.charAt(j)成立才退出
            while (j> 0 && dest.charAt(i) != dest.charAt(j)){
                j = next[j-1];
            }
            //当 dest.charAt(i) == dest.charAt(j) 满足时，部分匹配值就是+1
            if (dest.charAt(i) == dest.charAt(j)){
                j++;
            }
            next[i] = j;
        }
        return next;
    }
}


```



## 2.数据结构

### 1.单链表

```
创建单链表三部曲
	1.创建节点类 
	2.创建单链表类
	3.创建主函数测试类
```

![image-20220321163449232](C:\Users\17377\AppData\Roaming\Typora\typora-user-images\image-20220321163449232.png)

![image-20220321163319061](C:\Users\17377\AppData\Roaming\Typora\typora-user-images\image-20220321163319061.png)

![image-20220321163616231](C:\Users\17377\AppData\Roaming\Typora\typora-user-images\image-20220321163616231.png)

```java
package day0320;

public class SingleLinkedListDemo {
	public static void main(String[] args) {
		 	HeroNode hero1 = new HeroNode(1, "宋江", "及时雨");
	        HeroNode hero2 = new HeroNode(2, "卢俊义", "玉麒麟");
	        HeroNode hero3 = new HeroNode(3, "吴用", "智多星");
	        HeroNode hero4 = new HeroNode(4, "林冲", "豹子头");
	        SingleLinkedList singleLinkedList = new SingleLinkedList();
	        singleLinkedList.add(hero1);
	        singleLinkedList.add(hero2);
	        singleLinkedList.add(hero3);
	        singleLinkedList.add(hero4);
	        singleLinkedList.list();
	}
}
class SingleLinkedList{
	private HeroNode head = new HeroNode(0, null, null);
	public void add(HeroNode heroNode) {
		HeroNode temp = head;
		while (true) {
			if(temp.next==null) {
				break;
			}
			temp=temp.next;
		}
		temp.next=heroNode;
	}
	public void list() {
		if(head.next==null) {
			System.out.println("链表为空");
			return;
		}
		HeroNode temp = head.next;
		while(true) {
			if(temp==null) {
				break;
			}
			System.out.println(temp);
			temp=temp.next;
		}
	}
}

class HeroNode{
	public int no;
	public String name;
	public String nickname;
	public HeroNode next;
	public HeroNode(int no, String name, String nickname) {
		super();
		this.no = no;
		this.name = name;
		this.nickname = nickname;
	}
	@Override
	public String toString() {
		return "HeroNode [no=" + no + ", name=" + name + ", nickname=" + nickname +"]";
	}
	
}
```

### 2.图

```java
package day0322;

import java.util.ArrayList;
import java.util.Arrays;

public class Graph {
	private ArrayList<String> vertexList;// 储存顶点集合
	private int[][] edges;// 存储图对应的邻接矩阵
	private int numOfEdges;// 边的个数

	public static void main(String[] args) {
		// 图是否创建ok
		int n = 5; // 节点的个数
		String VertexValue[] = { "A", "B", "C", "D", "E" };
		// 创建图对象
		Graph graph = new Graph(n);
		// 利用foreach循环添加顶点
		for (String vertex : VertexValue) {
			graph.insertVertex(vertex);
		}
		//添加边
		//A-B A-C B-C B-D B-E
		graph.insertEdge(0, 1, 1);//A-B，A的下标为v1=0,B的下标为v=1 ，权值weight=1
		graph.insertEdge(0, 1, 1);
		graph.insertEdge(1, 2, 1);
		graph.insertEdge(1, 3, 1);
		graph.insertEdge(1, 4, 1);
		//显示矩阵
		graph.showGraph();
	}

	/**
	 * @param n 图顶点的个数
	 */
	public Graph(int n) {
		// 初始化矩阵和vertexList和其他属性
		edges = new int[n][n];
		vertexList = new ArrayList<String>(n);
		numOfEdges = 0;
	}

	// 图中常用的方法
	// 返回节点的个数
	public int getNumOfVertrex() {
		return vertexList.size();
	}

	// 得到边的数目
	public int getNumOfEdge() {
		return numOfEdges;
	}

	// 返回节点i对应的数据 0->A 1->B 2->C
	public String getValueByIndex(int i) {
		return vertexList.get(i);
	}

	// 返回v1 v2 的权值
	public int getWeight(int v1, int v2) {
		return edges[v1][v2];
	}

	// 显示图对应的矩阵
	public void showGraph() {
		for (int[] link : edges) {
			System.err.println(Arrays.toString(link));// 将link[] 一行一行显示
		}
	}

	// 插入结点
	public void insertVertex(String vertex) {
		vertexList.add(vertex);
	}

	// 添加边
	/**
	 * @param v1     第一个顶点的下标
	 * @param v2     第二个顶点的下标
	 * @param weight 权值
	 */
	public void insertEdge(int v1, int v2, int weight) {
		edges[v1][v2] = weight;
		edges[v2][v1] = weight;
		numOfEdges++;
	}
}

```

![image-20220322142157633](C:\Users\17377\AppData\Roaming\Typora\typora-user-images\image-20220322142157633.png)![image-20220322142245384](C:\Users\17377\AppData\Roaming\Typora\typora-user-images\image-20220322142245384.png)

图的深度优先搜索和广度优先搜索见算法5

## 3.算法例题

### 1.递归__字符串全排列问题

```java
package day01;

public class Permutation {
	static int[] arr = new int[] { 1, 2, 3 };

	public static void main(String[] args) {
		Permutation(arr, 0, 2);

	}

	public static void Permutation(int[] arr, int start, int end) {
		if (end <= 1) {
			return;
		}
		if (start == end) {
			for (int i = 0; i < arr.length; i++) {
				System.out.print(arr[i]);
			}
			System.out.println();
		} else {
			for (int i = start; i <= end; i++) {
				swap(arr, start, i);
				Permutation(arr, start + 1, end);
				swap(arr, start, i);
			}
		}
	}

	public static void swap(int[] arr, int start, int end) {
		int temp = 0;
		temp = arr[start];
		arr[start] = arr[end];
		arr[end] = temp;
	}
}

```

全排列图解：

即字符串abc定义一个头指针start-->a，尾指针-->c

将start指向的a与后面每一个字符进行交换，交换完一遍之后，start+1指向下一位字符b,将b利用递归同样与后面字符交换，交换完毕start向后移，直到start==end，全排列结束，此时再排列去重后输出即为全部全排列。

![img](https://img-blog.csdn.net/20180911222311273?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTQzMDM2NDc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

### 2.进制转换

```
二进制：b
十进制：d
八进制：o
十六进制：h
```

![image-20220323091131224](C:\Users\17377\AppData\Roaming\Typora\typora-user-images\image-20220323091131224.png)

![image-20220322220557677](C:\Users\17377\AppData\Roaming\Typora\typora-user-images\image-20220322220557677.png)

```java
public class Main {
	public static void main(String[] args) {
		int n = 18;
		Integer.toHexString(n);
		System.out.println(n + "的二进制是:" + Integer.toBinaryString(n)); //
		System.out.println(n + "的八进制是:" + Integer.toOctalString(n));
		System.out.println(n + "的十六进制是:" + Integer.toHexString(n));
		System.out.println(n + "的三进制是:" + Integer.toString(n, 3));
	}
}
```

任意进制转换方法：

```java
package day0323;

import java.util.Scanner;
//输入一个数，将其转换成任意进制
public class Text01 {
	public static void main(String[] args) {
		Scanner scan = new Scanner(System.in);
		int a = scan.nextInt();//被转换数
		int b = scan.nextInt();//转换进制
		StringBuilder bb = new StringBuilder(exChange(a, b));//创建一个字符串转换对象并赋初值exChange(a, b)，调用其reserve方法
		System.out.println(bb.reverse());
	}
	//定义进制转换方法
	/**
	 * @param a 10进制数
	 * @param b 转换进制
	 * @return
	 */
	public static String exChange(int a,int b) {
		String str = "0123456789ABCDEF";
		String result = "";
		result=str.charAt(a%b)+"";
		if(a==0) {
			return "";
		}
		return result+exChange(a/b, b);
	}
}

```

### 3.字符串转换

1）使用Str.toCharArray()方法将字符串转为字符数组

```java
public class Test {

    public static void main(String[] args) {

        // TODO Auto-generated method stub

        Scanner input = new Scanner(System.in);

        String str = input.next();

        char ss[] = str.toCharArray(); //利用toCharArray方法转换

        for (int i = 0; i < ss.length; i++) {

            System.out.println(ss[i]);

        }

    }
```

2)CharAt(i)方法用于返回字符串指定索引处的字符

```java
public static void main(String[] args) {
        String a = "abcde";
        String b = "abcdefg";
        //toCharArray() 方法将字符串转换为字符数组。
        char[] a1 = a.toCharArray();
        char[] chars = a.concat(b).toCharArray();
        System.out.println(Arrays.toString(chars));//Arrays.toString(数组)方法将数组输出格式
        //charAt() 方法用于返回指定索引处的字符。索引范围为从 0 到 length() - 1
        for (int i = 0; i < a1.length; i++) {
            char d = a.charAt(i);
            System.out.println("a-->"+d);
        }
    }

```

![img](https://img-blog.csdnimg.cn/20201221184240825.png)

4.时间格式转换

![image-20220401153909678](C:\Users\17377\AppData\Roaming\Typora\typora-user-images\image-20220401153909678.png)

```java
package tiankong;

import java.util.Scanner;


public class Main04 {
	public static void main(String[] args) {
		Scanner scan = new Scanner(System.in);
		Long n = scan.nextLong();
		n = n / 1000;// 一秒等于1000毫秒,因此不计入毫秒，在总数除以1000
//		System.out.println(24*60*60);//86400
		n = n % 86400;// 一天多出来的时间
		int h = (int) (n / (60 * 60));
		n = n % (60 * 60);// 一小时内多出来的时间
		int min = (int) (n / 60);
		int sec = (int) (n % 60);// 一分钟内多出来的时间
		System.out.printf("%d:%d:%d", h, min, sec);
	}
}
```

