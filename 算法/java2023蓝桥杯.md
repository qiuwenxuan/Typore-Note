### 不要因为数据类型错了而导致没分数

#### 1.1普通输入输出类型

输出：

```java
class Main{
    public static void main(String[] args){
        System.out.printf("Hello");
        System.out.printf("%d\n",10);//格式化输出,换行输出
        System.out.printf("%d",10);//不换行输出
        System.out.print("Hello");//输出不换行
        System.out.print("Hello\n");//输出后换行
        System.out.println("Hello");//输出后换行
    }
}
```

输入：

##### 1、使用Scanner类输入

```java
import java.util.Scanner;
class Main{
    public static void main(String[] args){
        Scanner input=new Scanner(System.in);
        String ch=input.next();
        String ch2=input.nextLine();
        System.out.println(ch);
        System.out.println(ch2);
    }
}
 
输入： 
fbh i fjovf
    
输出：
fbh
fbh i fjovf
```

> 这里不得不说到next（）和nextline()的区别，
>
> next()不会吸取字符前/后的空格/Tab键，只吸取字符，开始吸取字符（字符前后不算）直到遇到`空格/Tab键/回车`截止吸取；
> nextLine()吸取字符前后的空格/Tab键，`回车键`截止。
>
> 综上所述，next()的特性只能接收一个字符，而nextline()却能接收一行字符

其他类型输入：

```java
import java.util.Scanner;
class Main{
    public static void main(String[] args){
        Scanner input=new Scanner(System.in);
        int n=input.nextInt();//整数的输入
        char ch=input.next().charAt(0);//字符的输入
        double a=input.nextDouble();//浮点型的输入
        float y=input.nextFloat();
    }
}
```

##### 1.2输入输出流Buffered

> 1.首先先抛出异常 `throws IOException`
>
> 2.创建`BufferedReader/Writer` 对象br
>
> 3.按行输入，必要时进行split(" ")函数拆分成数组，用String[] 接收
>
> 4.因为输入的是字符串类型，需转换成需要的类型 输出的话也一样
>
> 5.关闭BUffered流br.close();也可以用flush()函数刷新缓冲流



首先定义输入输出

```java
static BufferedReader cin = new BufferedReader(new InputStreamReader(System.in));
static BufferedWriter cout = new BufferedWriter(new OutputStreamWriter(System.out));
12
```

使用方法如下：

```java
String[] firstline = cin.readLine().split(" ");
String[] secondline = cin.readLine().split(" ");
12
```

注意这个函数读入进来的是一个字符串，我们需要对其做分割。分割之后再对每个String做parseInt转成整数。
对于输出也只能输出字符串，如果需要输出一个数字，则需要+“ ”以转成字符串。最后记得把cin和cout全部close掉。

```
cout.write(ans+"");
cin.close();
cout.close();
123
```

下面看一道例题，对输入数据进行快速排序，然后输出第K位数据
[acwing786](https://www.acwing.com/problem/content/788/)
输入用例：

```c
5
3 1 2 4 5
12
import java.util.*;
import java.io.*;


class Main{
    static int N = 100010;
    static BufferedReader cin = new BufferedReader(new InputStreamReader(System.in));
    static BufferedWriter cout = new BufferedWriter(new OutputStreamWriter(System.out));
    
    
    public static void quickSort(int[] arr, int l, int r){
        if(l >= r) return;
        int i = l - 1, j = r + 1;
        int key = arr[l];
        while(i < j){
            while(arr[++i] < key);
            while(arr[--j] > key);
            if(i < j){
                int tmp = arr[i];
                arr[i] = arr[j];
                arr[j] = tmp;
            }
        }
        quickSort(arr, l, j);
        quickSort(arr, j + 1, r);
    }
   
    
    public static void main(String[] args) throws IOException{
        int[] arr = new int[N];
        String[] firstline = cin.readLine().split(" ");
        String[] secondline = cin.readLine().split(" ");
        int n = Integer.parseInt(firstline[0]);
        int k = Integer.parseInt(firstline[1]);
        for(int i = 0; i < n; i++){
            arr[i] = Integer.parseInt(secondline[i]);
        }
        quickSort(arr, 0, n - 1);
        int ans = arr[k - 1];
        cout.write(ans+"");
        cin.close();
        cout.close();
    }
}
```

#### `1.2 String`类

格式化字符串

类似于C++中的printf。用于输出指定位数小数，输出特定格式字符串等。

```java
package com.lxs;

public class Main
{
    public static void main(String[] args)
    {
        //处理小数位数
        System.out.printf("%.2f\n",3.14159);//输出3.14，保留两位小数

        //格式化字符串
        String s=String.format("括号中间有个数字:[%d]",3);
        System.out.println(s);//结果为：括号中间有个数字:[3]
    }
}
1234567891011121314
```

访问`String`中的字符

```Java
String str="Hello World";
for (int i = 0; i < str.length(); i++)
{
    System.out.print(str.charAt(i)+" ");
    //结果为：H e l l o   W o r l d 
}
123456
```

常用API：

- `split(String regex)`：[分割字符串](https://so.csdn.net/so/search?q=分割字符串&spm=1001.2101.3001.7020)

  ```java
  String [] str="hello world".split(" ");//字符串数组存放由" "划分的每个字符串 
  for(String x:str)
  {
      System.out.println(x);//hello '换行' world
  }
  12345
  ```

- `indexOf(char c)`、`indexOf(String str)`：查找，找不到返回-1

- `equals()`：判断两个字符串是否相等，注意不能直接用`==`

- `compareTo()`：判断两个字符串的[字典序](https://so.csdn.net/so/search?q=字典序&spm=1001.2101.3001.7020)大小，负数表示小于，0表示相等，正数表示大于

- `startsWith()`：判断是否以某个前缀开头

- `endsWith()`：判断是否以某个后缀结尾

- `trim()`：去掉首位的空白字符

- `toLowerCase()`：全部用小写字符 `toUpperCase()`：全部用大写字符

- `replace(char oldChar, char newChar)`：替换字符

- `replace(String oldRegex, String newRegex)`：替换字符串

- `substring(int beginIndex, int endIndex)`：返回`[beginIndex, endIndex)`中的子串

------

`StringBuilder`、`StringBuffer`

`String`不能被修改，如果打算修改字符串，可以使用`StringBuilder`和`StringBuffer`。

`StringBuffer`线程安全，速度较慢；`StringBuilder`线程不安全，速度较快。

```java
StringBuffer str=new StringBuffer("Hello");
str.append("World");//附加字符串
System.out.println(str);//HelloWorld

str.setCharAt(0, (char) (str.charAt(0)+1));//将原来字符串第一个字符加1
System.out.println(str);//IelloWorld（H加1变成I）
123456
```

常用API：

- `reverse()`：翻转字符串



java当中int与String相互转换

> int转String：
>
> - Integer类的toString方法：
>
> ```
> int mun = 123;
> String str = Integer.toString(mun);
> ```
>
> - String类的valueOf()方法：
>
> ```
> int num = 123;
> String str = String.valueOf(num);
> ```

> String转int:
>
> - Integer的parselnt()方法
>
> ```
> String s = "123";
> int num = Integer.parselnt(s);
> ```
>
> - 



### 2.java自定义排序

#### 一、普通类型数组int[]排序

对于普通类型int[]数组排序，java当中的Arrays类提供了几种方法：

```java
Arrays.sort(int[] a)//：按照数字顺序排列指定的数组
sort(int[] a, int fromIndex, int toIndex)//：按升序排列数组的指定范围
Arrays.parallelSort(int[] a)// ：按照数字顺序排列指定的数组
Arrays.parallelSort(int[] a, int fromIndex, int toIndex) //：按照数字顺序排列数组的指定范围
```

对于其它基本类型数组，也有相同的方法，直接把参数换成其它基本类型数组即可。注意，这些方法只能进行`升序`排序，不能自定义排序规则。想要自定义排序规则，只能将其转为Integer[]数组。

#### 二、包装类型数组Integer[]

对于包装类型数组，通过重写Arrays.sort方法来自定义排序

```java
public class Solution {
    public String sort(Integer[] nums) {
        Arrays.sort(nums, new Comparator<Integer>() {
            @Override
            public int compare(Integer o1, Integer o2) {
            	//从大到小的顺序排序
                return o2 - o1;
            }
        });
        return Arrays.toString(nums);
    }
}

public class Main {
    public static void main(String[] args) {
        Solution solution = new Solution();
        Integer[] arr = {1, 2, 3, 4, 5};
        System.out.println(solution.sort(arr));
    }
}

输出结果：[5, 4, 3, 2, 1]
```

自定义排序时，最重要的就是重写`compare(Integer o1, Integer o2)`方法，o1代表相邻元素的右边，o2代表相邻元素的左边，`return o1-o2 ;//从小到大`；`return o2-o1;//从大到小`

- 返回值<0：交换o1和o2的位置
- 返回值=0：不交换位置，不排序
- 返回值>0：不交换o1和o2的位置

#### 三、对象数组的排序

类实现`Comparable`接口，实现`compareTo(T o)`方法：

```java
public class Employee implements Comparable<Employee>{
    public String name;
    public Integer salary;

    public Employee(String name, Integer salary){
        this.name = name;
        this.salary = salary;
    }

	//实现排序的关键方法
    @Override
    public int compareTo(Employee e) {
        if (this.salary > e.salary){
            return 1;
        }else if (this.salary < e.salary){
            return -1;
        }else{
            return 0;
        }
    }
//这里this.salary其实就相当于前面compare(Integer o1, Integer o2)方法中的o1，它是指向数组中后一个元素的，e.salary则是指向数组中前一个元素，相当于o2。
    //这里定义好了对象Employee类的排序规则，只需要再调用Arrays(Employee.对象，l，r)就可以按照定义的规则进行排序
    @Override
    public String toString() {
        return "Employee{" +
                "name='" + name + '\'' +
                ", salary=" + salary +
                '}';
    }
}

public class Solution {//调用sort1方法进行排序，排序结果将根据自定义结果一样
    public Employee[] sort1(Employee[] nums) {
        Arrays.sort(nums);
        return nums;
    }
}

public class Main {
    public static void main(String[] args) {
        Solution solution = new Solution();
        Employee zhangsan = new Employee("张三", 1000);
        Employee lisi = new Employee("李四", 2000);
        Employee wangwu = new Employee("王五", 3000);
        Employee[] arr1 = {lisi, wangwu, zhangsan};
        Employee[] sort1 = solution.sort1(arr1);
        System.out.println("------------方法一---------------");
        for (Employee e : sort1){
            System.out.println(e);
        }
}
Employee{name=‘张三’, salary=1000}
Employee{name=‘李四’, salary=2000}
Employee{name=‘王五’, salary=3000}
```

### 3.StringBuilder

StringBuilder方法：`append()`,`reverse()`,`toString()`;

```java
StringBuilder sb = new StringBuilder("abc");
sb.append("def")//连接字符串
sb.append("ghi")//最后输出abcdefghi append()连接字符串速度更快

sb.reverse();//翻转字符串

String str = sb.toString();//由于StringBuilder创建的对象只是一个容器类，没有一个具体的类型，因此我们要把它转化为String类型才能使用一系列字符串方法

```

### 4.取字符串一小段函数substring

`String.substring(int beginIndex, int endIndex)` 取字符串的范围为[begin,end)，即不包含结尾的end

```java
String str = "hello word!";

System.out.println(str.substring(1,4));

System.out.println(str.substring(3,5));

System.out.println(str.substring(0,4));

将得到结果为：

ell

lo

hell
```

### 5.查找主字符串索引indexOf（）

`str.indexOf()`和`str.lastindexOf()`

```java
String s = "123abcabc";
String s1 = "123";
String s2 = "abc";

s.indexOf(s1);//表示在主串当中查找与s1相同的第一个字符串的第一个字符索引索引
s.lastIndexOf(s2);//表示在主串当中查找与s2相同的最后一个字符串的第一个字符索引

输出：
    0
    6
```



### 4.集合

- 数组长度固定
- 集合长度可变，且只能存取引用数据类型（基本类型需转换成包装类）

#### 1.ArrayList

```
ArrayList<String> list = new Arraylist<>();//泛型可以限制集合存储的数据类型，且后面的泛型可以省略
```

ArrayList 方法合集：

```java
add(e);//再加一个集合元素，并返回一个boolean值（无论添加与否都返回true）
remove(e);//删除值
set(int index,e);//修改指定下标的值
get(int index);//查询下标的值
int size();//获取长度
```

![image-20230323213052322](C:\Users\17377\AppData\Roaming\Typora\typora-user-images\image-20230323213052322.png)

#### 2.单列集合Collection

![image-20230323213225492](C:\Users\17377\AppData\Roaming\Typora\typora-user-images\image-20230323213225492.png)

接口：Collection List Set

实现类：`ArrayList LinkedList Vector`  `HashSet  TreeSet  LinkedHashSet`

- List系列集合：添加元素有序(是指存取有序，而不是在集合内排序)、可重复、有索引
- Set系列集合：添加的元素是无序、不重复、无索引

Collection是单列集合的父接口，子接口或实现类可以用父类所有方法：

```java
Collection list = new ArrayList();
list.add(e);
list.clear();//清空集合所有元素
list.remove(e);//删除元素
list.contains(Object o);//判断集合内是否含有该对象，返回boolean值
list.isEmpty();//判断是否为空
list.size();//集合长度
```

#### 3.迭代器 Iterator

```java
Iterator<String> it = list.iterator();//创建指针，利用list的iterator方法创建迭代器对象it，且it默认指针为0索引
boolean flag = it.hasNext();//判断it指针是否有元素
String str = it.next();//获取it当前指针对应的元素并移动指针到下一位
```

```java
Iterator<String> it = list.iterator();//一般迭代器循环格式
while(it.hasNext()){
	String str = it.next();
	Sysout(str);
}
```

#### 4.Set集合

Set集合特点:

1. 无序：存储顺序不止
2. 不重复：可以去除重复
3. 无索引：没有带索引的方法，所以不能使用普通for循环遍历，也不能通过索引来获取元素

Set集合的实现类：

- HashSet:无序，不重复，无索引
- LinkedHashSet:有序，不重复，无索引
- TreeSet:可排序，不重复，无索引

HashSet

- HashSet集合底层采取哈希表存储数据
- 哈希表是一种对应于增删改查数据性能都较好的选择

#### 5.双列集合Map

Map根类API

![image-20230324103724994](C:\Users\17377\AppData\Roaming\Typora\typora-user-images\image-20230324103724994.png)

```java
Map<Integer, String> ls = new HashMap<>();

        ls.put(1, "zhangsan");//添加键值对对象Entry
        ls.put(2, "lisi");
        ls.put(3, "wangwu");
//1：表示键  zhangsan：表示值
//put方法
        ls.remove(2);//删除对象，里面填的是key键

        ls.clear();

        ls.containsKey(3);//判断集合类是否有该键，返回一个boolean值
        ls.containsValue("zhangsan");//判断集合是否有该值，返回一个boolean值

        ls.isEmpty();//判断集合是否为空

        ls.size();//输出集合长度int
```

Map重要方法：

- map.keySet(); 返回一个Set集合，将Map集合当中所有键key存入到j集合Set当中
- map.entrySet();//返回一个Set<Map.Entry<Integer, String>>集合，Entry为map集合当中每一条键值对的封装对象，将对象Entry存入Set;

```java
 Map<String, String> map = new HashMap<>();

        map.put("益智拼", "小龙女");
        map.put("郭靖", "杨过");
        map.put("欧阳克", "黄蓉");

        Set<String> keys = map.keySet();//利用keySet方法增强循环key，通过get(key)得到对应的value

        for (String key : keys) {
            String value = map.get(key);
            System.out.println(key + "=" + value);
        }
//通过map.entrySet()方法得到键值对对象entrise，然后通过对象的getValue()和getKey()方法返回键值对对应的值；
Set<Map.Entry<Integer, String>> entries = map.entrySet();
        for (Map.Entry<Integer, String> entry : entries) {

            Integer key = entry.getKey();
            String value = entry.getValue();
            System.out.println(key + "=" + value);
        }
网慢
赞助
秋千
这两个
1=网慢
2=赞助
3=秋千
4=这两个
```



6.ArrayList利用HashSet集合去重

```java
ArrayList<Integer> list = new ArrayList<>();
        list.add(1);
        list.add(3);
        list.add(2);
        list.add(3);

        Iterator<Integer> it = list.iterator();

        while (it.hasNext()) {
            int s = it.next();
            System.out.print(s + " ");
        }

        System.out.println();
        HashSet<Integer> set = new HashSet<>(list);//利用构造初始化转化成HashSet去重
        for (Integer i : set) {
            int i1 = i;
            System.out.print(i1 + " ");
        }
        ArrayList<Integer> list2 = new ArrayList<>(set);//再将HashSet转化成原来的ArrayList集合

去重前：1 3 2 3 
去重后：1 2 3 

```



## 5.java System.exit(0)；

在 Java 中，可以使用 `System.exit(int status)` 函数来退出程序。当调用该函数时，程序将以指定的状态码退出。如果状态码为 0，则表示程序正常退出。

例如以下一行代码：

```java
public class Main02 {
    public static void main(String[] args) {
        int a = 10;
        int b = 0;
        int res = a / b;
        System.out.println(res);
        System.exit(0);
    }
}

```

报错：没有特定输出

![image-20230329161019165](C:\Users\17377\AppData\Roaming\Typora\typora-user-images\image-20230329161019165.png)

这时我们可以利用`System.exit(0)`函数来二分查找错误的语句：

![image-20230329161135095](C:\Users\17377\AppData\Roaming\Typora\typora-user-images\image-20230329161135095.png)

依旧显示报错；

![image-20230329161211585](C:\Users\17377\AppData\Roaming\Typora\typora-user-images\image-20230329161211585.png)

![image-20230329161220461](C:\Users\17377\AppData\Roaming\Typora\typora-user-images\image-20230329161220461.png)

运行结果正常，说明错误出现在第五行与第八行之间，即int res = a / b ;

该方法用来查找无输出的报错有奇效；

## 6.DP动态规划

```java
动态规划模板：
dp[0][0][...] = 边界值
for(状态1 ：所有状态1的值){
    for(状态2 ：所有状态2的值){
        for(...){
          //状态转移方程
          dp[状态1][状态2][...] = 求最值
        }
    }
}
```



### 1、 01背包问题

![image-20230329204617493](C:\Users\17377\AppData\Roaming\Typora\typora-user-images\image-20230329204617493.png)

![image-20230329194933304](C:\Users\17377\AppData\Roaming\Typora\typora-user-images\image-20230329194933304.png)

状态计算可分为两部分：

1、所有选择第i个物品的方案: `= f[i-1,j-v[i]]+w[i]`

2、所有不选择第i个物品的方案：`=f[i-1,j]`

因此我们的决策是选最大值，因此`f[i,j] = max( f[i-1,j-v[i]]+w[i],f[i-1,j]);`

```java
Java代码：
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;

public class Main03 {
    static BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
    static int[] V = new int[1010];
    static int[] W = new int[1010];
    static int[][] f = new int[1010][1010];//f[i][j]表示前i物品个容积不超过j的最大价值

    //求总价值最大 属性为MAX
    public static void main(String[] args) throws IOException {
        String[] s1 = br.readLine().split(" ");
        int n = Integer.parseInt(s1[0]);
        int v = Integer.parseInt(s1[1]);

        for (int i = 1; i <= n; i++) {
            String[] ss = br.readLine().split(" ");
            V[i] = Integer.parseInt(ss[0]);
            W[i] = Integer.parseInt(ss[1]);
            for (int j = 1; j <= v; j++) {
                if (j >= V[i]) {
                    f[i][j] = Math.max(f[i - 1][j], f[i - 1][j - V[i]] + W[i]);
                } else {
                    f[i][j] = f[i - 1][j];
                }
            }
        }

       
        System.out.println(f[n][v]);
    }
}

```



### 2、摘花生问题

![image-20230329204551826](C:\Users\17377\AppData\Roaming\Typora\typora-user-images\image-20230329204551826.png)

![image-20230329204343358](C:\Users\17377\AppData\Roaming\Typora\typora-user-images\image-20230329204343358.png)

核心代码：`f[i] [j]= Math.max(f[i] [j - 1] + w[i] [j], f[i - 1] [j] + w[i] [j]);`

代码：

```java
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;

public class Main01 {
    static BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
    static int[][] w = new int[110][110];
    static int[][] f = new int[110][110];
    static int[] res = new int[110];

    public static void main(String[] args) throws IOException {
        String s1 = br.readLine();
        int T = Integer.parseInt(s1);
        int Q = T;
        while (Q-- > 0) {
            String[] s2 = br.readLine().split(" ");
            int R = Integer.parseInt(s2[0]);
            int C = Integer.parseInt(s2[1]);

            for (int i = 1; i <= R; i++) {
                String[] s3 = br.readLine().split(" ");
                for (int j = 1; j <= C; j++) {
                    w[i][j] = Integer.parseInt(s3[j - 1]);
                }
            }

            for (int i = 1; i <= R; i++) {
                for (int j = 1; j <= C; j++) {
                    f[i][j] = Math.max(f[i][j - 1] + w[i][j], f[i - 1][j] + w[i][j]);
//                    System.out.print(f[i][j] + " ");
                }
//                System.out.println();
            }

            res[T - Q] = f[R][C];
//            System.out.println(T - Q);
//            System.out.println(res[T]);
        }
        int i = 1;
        while (res[i] != 0) {
            System.out.println(res[i]);
            i++;
        }
    }
}

```



### 3、最长上升子序列

![image-20230330195546799](C:\Users\17377\AppData\Roaming\Typora\typora-user-images\image-20230330195546799.png)

![image-20230330195555682](C:\Users\17377\AppData\Roaming\Typora\typora-user-images\image-20230330195555682.png)

动态规划问题未必都是打印最后的f[n]或者f [n] [m]，切忌思维定式啊！！

因为这道题与以上几道题`不同之处在于`，f[i]表示的是以i结尾的最长上升子序列的集合，虽然属性是max，但是由于给出的数组无序，因此每一个数组a[i]（i从0~n）都有可能为最长上升子序列,因此我们可以遍历或者定义一个max变量存储最大值；因此此题的解不为f[n];

```java
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;

//状态表示：f[i]表示所有以i结尾的单调递增的子序列，求：max最长的单调递增子序列
public class Main02 {
    static BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
    static int[] a = new int[1010];
    static int[] f = new int[1010];

    public static void main(String[] args) throws IOException {
        String s1 = br.readLine();
        int n = Integer.parseInt(s1);
        String[] ss = br.readLine().split(" ");
        for (int i = 1; i <= n; i++) {
            a[i] = Integer.parseInt(ss[i - 1]);
        }
        int res = 1;
        f[1] = 1;//如果f[1]不满足a[j] < a[i]，最长子序列就是它本身长度为1
        for (int i = 2; i <= n; i++) {
            for (int j = 1; j < i; j++) {
                if (a[j] < a[i]) {
                    f[i] = Math.max(f[i], f[j] + 1);
//                    System.out.println("以 " + a[i] + " 结尾的最长上升子序列为:" + f[i]);
                }
                res = Math.max(res, f[i]);//定义一个res接收最大的子序列结果，或者循环遍历所有数组得出最大的f[i]
            }
        }
        System.out.println(res);

    }
}

```





### 4、地宫取宝 `综合题`

![image-20230330212226110](C:\Users\17377\AppData\Roaming\Typora\typora-user-images\image-20230330212226110.png)

![image-20230330212853843](C:\Users\17377\AppData\Roaming\Typora\typora-user-images\image-20230330212853843.png)

该题综合考察了以上所有的动态规划模板：包括 取与不取，从上到下从左到右，取最后一个物品价值不同三个模板，f[i,j,k,c]更是上升到4维，由于本题找的属性属性的是所有数量count，因此需要循环累加最后一个物品是C所有的方案数

```java
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;

public class Main03 {
    static BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
    static int[][] w = new int[55][55];
    static int[][][][] f = new int[55][55][13][14];
    static int MOD = 1000000007;
//f[i,j,k,c]表示：所有从起点走到（i,j），且已经取了k件物品，且最后一件物品的价格是C的合法方案的集合
    //属性：数量count

    public static void main(String[] args) throws IOException {
        String[] s1 = br.readLine().split(" ");
        int n = Integer.parseInt(s1[0]);
        int m = Integer.parseInt(s1[1]);
        int k = Integer.parseInt(s1[2]);

        for (int i = 0; i < n; i++) {
            String[] s2 = br.readLine().split(" ");

            for (int j = 0; j < m; j++) {
                w[i][j] = Integer.parseInt(s2[j]);
                w[i][j]++;//
            }

        }
        //初始化两个值：取第一件物品与不取第一件物品的合法方案为1，
        f[1][1][1][w[1][1]] = 1;
        f[1][1][0][0] = 1;

        for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= m; j++) {
                if (i == 1 && j == 1) continue;
                for (int u = 0; u <= k; u++) {
                    for (int v = 0; v <= 13; v++) {
                        //这里表示不取的情况
                        f[i][j][u][v] += f[i - 1][j][u][v] % MOD;
                        f[i][j][u][v] += f[i][j - 1][u][v] % MOD;
                        if (u > 0 && v == w[i][j]) {//这里表示取需要满足条件为u > 0 && v == w[i][j]即取的物品数>0,且取的物品的价值为w[i][j];
                            for (int c = 0; c < v; c++) {
                                f[i][j][u][v] += f[i - 1][j][u - 1][v] % MOD;
                                f[i][j][u][v] += f[i - 1][j][u - 1][v] % MOD;
                            }
                        }
                    }
                }
            }
        }
        int res = 0;
        for (int i = 0; i <= 13; i++) {//循环最后一个物品最大价值不同的C的方案数并累加count，由于本题C最大为13,循环最大值C=13不必考虑具体值
            res += f[n][m][k][i] % MOD;
        }
        System.out.println(res);
        br.close();

    }
}
```

### 5、动态规划小结

> 综上所述：所有动态规划问题，先搞清楚属性count,min,max。如果是max则需要对方案多个情况求max，如果只有两个方案直接max(a,b);如果有多个方案则需要循环或者定义一个变量max接收最大值
>
> 动态规划问题未必都是打印最后的f[n]或者f [n] [m]，切忌思维定式啊！！也有可能输出res(res可能为方案数的累加或者多种情况的最大值)
>
> 判断动态规划设计是否成功，就看动态规划]有没有用到输入的数组（输入值）w[i,j]，一般为要么公式f[i,j]直接用到w[i,j]，要么就是以w[i,j]为条件影响输入值
>
> ```java
> 如背包问题：f[i,j]包含输入值w
> 输入：
> V[i] = Integer.parseInt(ss[0]);
> W[i] = Integer.parseInt(ss[1]);
> 公式就含有（V[i]]，W[i]）
>   f[i][j] = Math.max(f[i - 1][j], f[i - 1][j - V[i]] + W[i]);
> ```
>
> ```java
> 如最长上升子序列，以输入为条件判断从而影响f[i,j]
> if (a[j] < a[i]) {
>        f[i] = Math.max(f[i], f[j] + 1);
> }
> ```
>
> 

### 6.走方格 `dfs递归` `动态规划`

![image-20230327211444715](C:\Users\17377\AppData\Roaming\Typora\typora-user-images\image-20230327211444715.png)

第一种方法：dfs（会显示超时）

Java代码：

```java
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.Arrays;

public class Main06 {
    static BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
    static Boolean[][] used;
    static int[] dx = new int[]{0, 1};
    static int[] dy = new int[]{1, 0};
    static int n, m, res;

    public static void main(String[] args) throws IOException {
        String[] s = br.readLine().split(" ");
        n = Integer.parseInt(s[0]);
        m = Integer.parseInt(s[1]);
        used = new Boolean[32][32];
        for (int i = 0; i < used.length; i++) {//给boolean used数组全部赋值为false,否则会出现used为null的异常
            Arrays.fill(used[i], false);
        }

        dfs(1, 1);
        System.out.println(res);
        br.close();
    }

    private static void dfs(int x, int y) {
        if (x > n || y > m) return;
        if (x == n && y == m) res++;

        for (int i = 0; i < 2; i++) {
            int xx = x + dx[i];
            int yy = y + dy[i];

            if (used[xx][yy] == true || (xx % 2 == 0 && yy % 2 == 0)) continue;
            if (xx > n || yy > m || xx < 1 || yy < 1) continue;
            used[xx][yy] = true;
            dfs(xx, yy);
            used[xx][yy] = false;
        }
    }
}

```

第二种方法：动态规划

动态规划求走方格方案数(count)： `f[i,j] = f[i-1,j]+f[i,j-1];` 由于只能向下或向右，即走到该方格的方案数等于左边方格方案数+上边方格方案数；

![image-20230405162609231](C:\Users\17377\AppData\Roaming\Typora\typora-user-images\image-20230405162609231.png)

java代码：

```java
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;

//f[i][j]表示走到（i,j）上的方案数count
public class Main07 {
	static BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
	static int[][] f = new int[40][40];
	static int n, m;

	public static void main(String[] args) throws IOException {
		String[] s1 = br.readLine().split(" ");
		n = Integer.parseInt(s1[0]);
		m = Integer.parseInt(s1[1]);
		f[1][1] = 1;
		for (int i = 1; i <= n; i++) {
			for (int j = 1; j <= m; j++) {
				if (i == 1 && j == 1)
					continue;
				if (!(i % 2 == 0 && j % 2 == 0)) {

					f[i][j] = f[i - 1][j] + f[i][j - 1];
				}
			}
		}
		System.out.println(f[n][m]);
	}
}

```

### 7.跳台阶问题

> 一只青蛙一次可以跳上1级台阶，也可以跳上2级台阶。求该青蛙跳上一个 10 级的台阶总共有多少种跳法。

- 要想跳到第10级台阶，要么是先跳到第9级，然后再跳1级台阶上去;要么是先跳到第8级，然后一次迈2级台阶上去。
- 同理，要想跳到第9级台阶，要么是先跳到第8级，然后再跳1级台阶上去;要么是先跳到第7级，然后一次迈2级台阶上去。
- 要想跳到第8级台阶，要么是先跳到第7级，然后再跳1级台阶上去;要么是先跳到第6级，然后一次迈2级台阶上去。

 	假设跳到第n级台阶的跳数我们定义为f(n)，很显然就可以得出以下公式：

```text
f（10） = f（9）+f(8)
f (9)  = f(8) + f(7)
f (8)  = f(7) + f(6)
...
f(3) = f(2) + f(1)

即通用公式为: f(n) = f(n-1) + f(n-2)
```

那f(2) 或者 f(1) 等于多少呢？

- 当只有2级台阶时，有两种跳法，第一种是直接跳两级，第二种是先跳一级，然后再跳一级。即f(2) = 2;
- 当只有1级台阶时，只有一种跳法，即f（1）= 1；

因此可以用递归去解决这个问题：

```java
class Solution {
    public int numWays(int n) {
    if(n == 1){
        return 1;
    }
     if(n == 2){
        return 2;
    }
    return numWays(n-1) + numWays(n-2);
    }
}
```

为什么超时了呢？递归耗时在哪里呢？先画出**递归树**看看：

![img](https://pic3.zhimg.com/80/v2-2dc11311d9321f61c7bb8a3d9058c636_720w.webp)

- 要计算原问题 f(10)，就需要先计算出子问题 f(9) 和 f(8)
- 然后要计算 f(9)，又要先算出子问题 f(8) 和 f(7)，以此类推。
- 一直到 f(2) 和 f(1），递归树才终止。

回过头来，你仔细观察这颗递归树，你会发现存在大量重复计算，比如f（8）被计算了两次，f（7）被重复计算了3次...所以这个递归算法低效的原因，就是**存在大量的重复计算**！

既然存在大量重复计算，那么我们可以先把计算好的答案存下来，即造一个备忘录，等到下次需要的话，先去备忘录查一下，如果有，就直接取就好了，备忘录没有才开始计算，那就可以省去重新重复计算的耗时啦！这就是带备忘录的解法。

**带备忘录的递归解法（自顶向下）**

一般使用一个数组或者一个哈希map充当这个**备忘录**。

- 第一步，f（10）= f(9) + f(8)，f(9) 和f（8）都需要计算出来，然后再加到备忘录中，如下：

![img](https://pic4.zhimg.com/80/v2-f31e17b883d1eb45a906a83760b5e7f3_720w.webp)

- 第二步， f(9) = f（8）+ f（7），f（8）= f（7）+ f(6), 因为 f(8) 已经在备忘录中啦，所以可以省掉，f(7),f（6）都需要计算出来，加到备忘录中~

![img](https://pic1.zhimg.com/80/v2-5c553e02bb63d74f9f1f3b91b994f584_720w.webp)

第三步， f(8) = f（7）+ f(6),发现f(8)，f(7),f（6）全部都在备忘录上了，所以都可以剪掉。

![img](https://pic4.zhimg.com/80/v2-7675d5727f4e81db7fc897051ae2cecf_720w.webp)

所以呢，用了备忘录递归算法，递归树变成光秃秃的树干咯，如下：

![img](https://pic2.zhimg.com/80/v2-6c180511b9a2ef31f76c225b50f7cb9d_720w.webp)

带**备忘录**的递归算法，子问题个数=树节点数=n，解决一个子问题还是O(1),所以带**备忘录**的递归算法的时间复杂度是O(n)。接下来呢，我们用带**备忘录**的递归算法去撸代码，解决这个青蛙跳阶问题的超时问题咯~，代码如下：

```java
public class Solution {
    //使用哈希map，充当备忘录的作用
    Map<Integer, Integer> tempMap = new HashMap();
    public int numWays(int n) {
        // n = 0 也算1种
        if (n == 0) {
            return 1;
        }
        if (n <= 2) {
            return n;
        }
        //先判断有没计算过，即看看备忘录有没有
        if (tempMap.containsKey(n)) {
            //备忘录有，即计算过，直接返回
            return tempMap.get(n);
        } else {
            // 备忘录没有，即没有计算过，执行递归计算,并且把结果保存到备忘录map中，对1000000007取余（这个是leetcode题目规定的）
            tempMap.put(n, (numWays(n - 1) + numWays(n - 2)) % 1000000007);
            return tempMap.get(n);
        }
    }
}
```

我们来看下自底向上的解法，从f(1)往f(10）方向，想想是不是直接一个for循环就可以解决啦，如下：

![img](https://pic2.zhimg.com/80/v2-ace286214f56e1f2c70ff22307ac8ea9_720w.webp)

```java
代码如下：
import java.util.Scanner;
//求方案数count
public class Main12 {
	public static void main(String[] args) {
		Scanner scan = new Scanner(System.in);
		int n = scan.nextInt();
		int[] f = new int[n+5];
		f[1] = 1;//定义边界
		f[2] = 2;
		for (int i = 1; i <= n; i++) {
			if (i == 1 || i == 2)
				continue;
			f[i] = f[i - 1] + f[i - 2];
		}
		System.out.println(f[n]);
	}
}

```

**什么样的问题可以考虑使用动态规划解决呢？**

> ★ 如果一个问题，可以把所有可能的答案穷举出来，并且穷举出来后，发现存在重叠子问题，就可以考虑使用动态规划。

## 7.浮点数精度问题

在浮点数当中由于存在精度问题，如果两个数相等，系统也可能会判定两个数不同，因此我们可以让两个浮点数特判一下，如:(double)a-(double)b <1e-8我们就可以判断两数相等，为同一个数。

![image-20230402101731160](C:\Users\17377\AppData\Roaming\Typora\typora-user-images\image-20230402101731160.png)

## 8.函数Math.ceil() 

Math.ceil(1.23)//向上取整

java当中int运算都是直接抛弃整数部分向下取整

## 9.最大公因数与最小公倍数

gcd()，lcm()

1、最大公因数（欧几里得算法）

```java
int gcd(int a, int b) {//a保证大于b
        return b ? gcd(b, a % b) : a;
    }
```

2、最小公倍数 (a,b)[a,b]=ab(a,b均为整数)

```java
int lcm(int a, int b) {
        return a * b / gcd(a, b);
    }
```

## 10、判断闰年方法

年份是4的倍数而不是100的倍数，或者是年份是400的倍数

```java
(year % 4 == 0 && year % 100 != 0) || (year % 400 == 0)
```



## 11、进制转换

java自带进制转换函数：

```java
把十进制数字x转换成y进制
Integer.toString(x,y);
把y进制的数字x转换为十进制
Integer.parseInt(x,y);
```

有这些方法，当求任意进制转换时，我们可以把待转化的进制转为10进制，再将10进制转化成需要转化的进制（即以10进制为媒介）

```java
如：8进制转16进制
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;

public class Main08 {
	static BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
	static int n;
	static int[] result = new int[12];

	public static void main(String[] args) throws IOException {
		String s1 = br.readLine();
		int n = Integer.parseInt(s1);

		for (int i = 0; i < n; i++) {
			String s = br.readLine();
			int res = Integer.parseInt(s, 16);// 将16进制转化成10进制
//			System.out.println(res);
			String results = Integer.toString(res, 8);// 将10进制转化成16进制
			result[i] = Integer.parseInt(results);
		}
		
		for (int i = 0; i < n; i++) {

			System.out.println(result[i]);
		}
		br.close();

	}
}
```



### 1.高斯日记

![image-20230315143101847](C:\Users\17377\AppData\Roaming\Typora\typora-user-images\image-20230315143101847.png)

![image-20230315144258266](C:\Users\17377\AppData\Roaming\Typora\typora-user-images\image-20230315144258266.png)

```c
import java.util.Scanner;

public class Main02 {
    static int year, month, day;
    static int[] a = {0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};

    public static void main(String[] args) {

        year = 1777;
        month = 4;
        day = 30;
        Scanner scan = new Scanner(System.in);
        int num = scan.nextInt();
        for (int i = 1; i < num; i++) {
            if ((year % 4 == 0 && year % 100 != 0) || (year % 400 == 0)) {
                a[2] = 29;
            } else {
                a[2] = 28;
            }
            day = day % a[month] + 1;
            if (day == 1) {
                month = month % 12 + 1;
                if (month == 1) {
                    year += 1;
                }
            }
        }
        System.out.printf("%d-%d-%d\n", year, month, day);
    }
}

```



```java
 核心代码：
 day = day % a[month] + 1;
            if (day == 1) {
                month = month % 12 + 1;
                if (month == 1) {
                    year += 1;
                }
```

综上所述，进制转换要多用到%,即在某一个进制满时需要归零，然后再对下一个进制判断是否溢出，如果溢出则需归零再对下一个更高进制做同样的判断。

### 2.任意进制转换

这里任意进制转换的核心就是定义一个模板数组`String ss = "0123456789ABCDEFG";` ，然后通过递归代码`return exChange(num / n, n) + ss.charAt(num % n);` 不断递归输出即可，这里注意点是最先输出的`ss.charAt(num % n)`其在进制中的位次越小，因此`exChange(num / n, n) + ss.charAt(num % n)`当中`ss.charAt(num % n)`在前，`exChange(num / n, n)`在后，保证输出的结果不会倒置。

```java
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;

public class Main03 {
    static BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
    static String ss = "0123456789ABCDEFG";

    public static void main(String[] args) throws IOException {
        String[] s = br.readLine().split(" ");
        int num = Integer.parseInt(s[0]);
        int n = Integer.parseInt(s[1]);

        String res = exChange(num, n);
        System.out.println(res);
    }

    private static String exChange(int num, int n) {
        if (num == 0) {
            return "";
        }
        return exChange(num / n, n) + ss.charAt(num % n);
    }
}

```

### 3.含偏移量的进制转换

![image-20221123150616565](C:\Users\17377\AppData\Roaming\Typora\typora-user-images\image-20221123150616565.png)

```java
import java.util.Scanner;

class Main {
    public static void main(String[] args) {
        Scanner cin = new Scanner(System.in);
        int x = cin.nextInt();
        String s = "";//空数组接收值
        while (x > 0) {//判断值是否为0 
            s += (char) ((x - 1) % 26 + 'A');//这里因为'A'默认为1，因此x=1的话-1再加'A'刚好满足题意
            x = (x - 1) / 26;
        }
        for (int i = s.length() - 1; i >= 0; i--) {
            System.out.print(s.charAt(i));
        }
    }

}

```

### 4.时间格式转换

![image-20220401153909678](C:\Users\17377\AppData\Roaming\Typora\typora-user-images\image-20220401153909678.png)

```java
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;

public class Main04 {
    static BufferedReader br = new BufferedReader(new InputStreamReader(System.in));

    public static void main(String[] args) throws IOException {
        String s1 = br.readLine();
        Long l = Long.valueOf(s1);
        int h = 0;
        int m = 0;
        int s = 0;

        int a = (int) (l / 1000);//去除后三位毫秒

        for (int i = 1; i <= a; i++) {
            s = (s + 1) % 60;//这里之所以写成先(s + 1) % 60，也可以写成s%60+1,但是由于时间到59+1=60的时候就直接进位了因此不包括60
            if (s == 0) {
                m = (m + 1) % 60;
                if (m == 0) {
                    h = (h + 1) % 60;
                }
            }
        }
        System.out.printf("%d:%02d:%02d", h, m, s);
    }
}

```

### 5.综合归纳

> 进制转换包含时间格式转换，日期格式转换，还有任意进制转换，偏移量转换等等
>
> 时间，日期，偏移量等转换都可以用迭代判断法；
>
> ```java
> 时间格式转换：
> m = (m + 1) % 60;
> if (m == 0) {
> 	h = (h + 1) % 60;
> }
> 即先+1再模以进制大小，等m刚好到60的时候变为0，此时判断下一进制h是否溢出
> 
> ```
>
> 日期格式转换：（需要配合日期数组）`int[] a = {0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};`可能还需要用到闰年判断`if ((year % 4 == 0 && year % 100 != 0) || (year % 400 == 0))`
>
> ```java
> day = day % a[month] + 1;
> if (day == 1) {
> 	month = month % 12 + 1;
> 	if (month == 1) {
>          year += 1;
> 	}
> }
> 这里先%z再+1,是因为每月可以到30/31天再进一也可
> ```
>
> 偏移量转换：确实没有偏移量这么一说，但是由于这类题目没有0变量，比如例题当中A就为0,因此我们可以将输入x-1+'A'，即当x=1的时候变为0，刚好对应着'A'
>
> ```java
> s += (char) ((x - 1) % 26 + 'A');//这里因为'A'默认为1，因此x=1的话-1再加'A'刚好满足题意
> x = (x - 1) / 26;
> ```
>
> 

## 12、将字符串转换成字符数组

```java
 char ss[] = str.toCharArray(); //利用toCharArray方法转换
```

## 13.DFS和BFS

### Stack和Queue常用方法：

```java
poll与pop
Deque<Object> queue = new Linkedlist();//创建一个队列
Stack.pop();//移除堆栈顶部的对象，并作为此函数的值返回该对象 。
Queue.poll()//(队列)的一个方法，获取并移除此队列的头，如果此队列为空，则返回null。
    
boolean Queue.offer(E e);//将指定对象插入队列queue
```

### 1.DFS

n皇后问题：

![image-20230403104132203](C:\Users\17377\AppData\Roaming\Typora\typora-user-images\image-20230403104132203.png)

![微信图片_20220505182615.jpg](https://cdn.acwing.com/media/article/image/2022/05/05/3019_d7a30075cc-%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20220505182615.jpg)

```c
#include <iostream>
using namespace std;
const int N = 20; 

// bool数组用来判断搜索的下一个位置是否可行
// col列，dg对角线，udg反对角线
// g[N][N]用来存路径

int n;
char g[N][N];
bool col[N], dg[N], udg[N];

void dfs(int u) {
    // u == n 表示已经搜了n行，故输出这条路径
    if (u == n) {
        for (int i = 0; i < n; i ++ ) puts(g[i]);   // 等价于cout << g[i] << endl;
        puts("");  // 换行
        return;
    }

    // 枚举u这一行，搜索合法的列
    int x = u;
    for (int y = 0; y < n; y ++ )//遍历每行
        // 剪枝(对于不满足要求的点，不再继续往下搜索)  
        if (col[y] == false && dg[y - x + n] == false && udg[y + x] == false) {//每列和正反对角线都没有皇后，此时满足继续搜索条件
            col[y] = dg[y - x + n] = udg[y + x] = true;
            g[x][y] = 'Q';
            dfs(x + 1);
            g[x][y] = '.';  // 恢复现场
            col[y] = dg[y - x + n] = udg[y + x] = false;
        }
}

int main() {
    cin >> n;
    for (int i = 0; i < n; i ++ )
        for (int j = 0; j < n; j ++ )
            g[i][j] = '.';

    dfs(0);

    return 0;
}   

```

```java
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.Arrays;

public class Main13 {
	static BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
	static int n;
	static char[][] g = new char[15][15];
	static boolean[] col = new boolean[15];// 因为我们是按行搜索，因此只需要定义一个列数组存取该列是否可放置皇后
	static boolean[] dg = new boolean[15];
	static boolean[] udg = new boolean[15];

	public static void main(String[] args) throws IOException {
		n = Integer.parseInt(br.readLine());

		for (int i = 0; i < n; i++) {
			for (int j = 0; j < n; j++) {
				g[i][j] = '.';
			}
		}

		dfs(0);
	}

	private static void dfs(int u) {// 这里的u即代表递归的层数，也代表按每行搜索，搜索到了u行
		if (u == n) {
			for (int i = 0; i < n; i++) {
				for (int j = 0; j < n; j++) {
					System.out.print(g[i][j]);
				}
				System.out.println();
			}
			System.out.println();
			return;
		}
		
		int x = u;
		for (int y = 0; y < n; y++) {
			if (col[y] == false && dg[y + x] == false && udg[y - x + n] == false) {
				col[y] = dg[y + x] = udg[y - x + n] = true;
				g[x][y] = 'Q';
				dfs(x + 1);
				g[x][y] = '.';
				col[y] = dg[y + x] = udg[y - x + n] = false;
			}
		}

	}
}

```



### 2.BFS

BFS有很强的模板性：

BFS一般格式：

![image-20230403214303998](C:\Users\17377\AppData\Roaming\Typora\typora-user-images\image-20230403214303998.png)

```java
用代码写为：

queue.add(x,y);//放入初始值根节点
while(queue.isEmpty()){
	queue.poll();//返回对列头结点并再队列当中删除该节点对象
	if(终止条件){return 结果}
	if（拓展条件）{
		拓展队列节点；
	}
	return;
}
```

走迷宫

![image-20230403214109690](C:\Users\17377\AppData\Roaming\Typora\typora-user-images\image-20230403214109690.png)

广度优先搜索（BFS）适用于权值为1的寻找最短路径问题，采用队列quene结构存储



```c
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.ArrayDeque;
import java.util.Queue;

public class Main05 {
    static BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
    static int[][] map = new int[110][110];//  创建map数组存储地图
    static boolean[][] mark = new boolean[110][110];//  mark标记该点是否被走过
    static Queue<String> queue = new LinkedList<String>();//  创建一个Queue队列存取Point类对象
    static int n, m;

    static int[] dx = new int[]{-1, 0, 1, 0};//  位移向量x,y
    static int[] dy = new int[]{0, -1, 0, 1};

    static class Point {//  创建一个point类存取每个点的坐标和步数
        int x, y, step;

        public Point(int x, int y, int step) {//  含参构造方法
            this.x = x;
            this.y = y;
            this.step = step;
        }
    }

    public static void main(String[] args) throws IOException {
        String[] s1 = br.readLine().split(" ");

        n = Integer.parseInt(s1[0]);
        m = Integer.parseInt(s1[1]);

        for (int i = 1; i <= n; i++) {
            String[] ss = br.readLine().split(" ");
            for (int j = 1; j <= m; j++) {
                map[i][j] = Integer.parseInt(ss[j - 1]);
            }
        }

        int res = bfs();//  bfs()方法返回step(int)
        System.out.println(res);
        br.close();
    }

    private static int bfs() {
        int x = 1;//初值
        int y = 1;
        queue.offer(new Point(1, 1, 0));
        while (!queue.isEmpty()) {//   判断是否为空
            Point p = queue.poll();//  poll()函数返回队列头并将其移除出队列，此时第二个队列变成头队列
            if (p.x == n && p.y == m) {//  终止条件，当坐标等于出口时即x=n y=m;
                return p.step ;//  输出step值
            }

            for (int i = 0; i < 4; i++) {//  遍历目的节点的四个方向，判断是否满足条件
                x = p.x + dx[i];
                y = p.y + dy[i];

                if (x > 0 && y > 0 && x <= n && y <= m && mark[x][y] == false && map[x][y] == 0) {//x,y不越界，且mark[x][y]数组不被标记,且map[x][y]=0表示是通路，
                    mark[x][y] = true;//满足以上条件表示该路可通，mark数组标记为true
                    queue.add(new Point(x, y, p.step + 1));//将满足条件的遍历的节点坐标按顺序加入队列，先进先出，直到所有对列全部遍历完成
//                    System.out.println(p.step);
                }
            }
        }
        return 0;
    }
}

```

![在这里插入图片描述](https://img-blog.csdnimg.cn/94938a3f9ef24a1888e36a35eb69eb95.png)

队列quene广度搜索原理：

BFS要保证的第一件事就是我们需要先走最近的，因此，队列的作用就是基于此的。
![在这里插入图片描述](https://img-blog.csdnimg.cn/18247067a3dc4be4bba2e1cdd419d236.png)
![在这里插入图片描述](https://img-blog.csdnimg.cn/119658ef1c7f4e4bb24f4c50f3afde74.png)
![在这里插入图片描述](https://img-blog.csdnimg.cn/737970fb878645cf9ff27a57bc1bf47d.png)

即先将头结点放入队列，然后以头结点做操作按顺序查找所有头结点下一个节点并放入队列，当操作的头节点下一节点全部搜索完之后，头结点出队列，后续第二个节点变为头节点重复流程直到队列当中没有节点为止；

3.综合小结：

```
DFS是用Stack来存取，一般函数都是在栈中运行，所以无需额外开Stack来运算，一般用在递归上形式围殴dfs(u);
BFS是用queue来运算，所以需要开一个queue对列来存储数据，格式为dfs();不需要传参
java采用：Queue<String> queue = new LinkedList<String>();来创建队列
```

## 14.`Arrays.fill(arr,val)`方法

```java
import java.util.Arrays;
 
public class FillTest {
    public static void main(String args[]) {
        int array[] = new int[6];
        Arrays.fill(array, 100);//给数组array全部赋值100
        for (int i = 0, n = array.length; i < n; i++) {
            System.out.println(array[i]);
        }
 
        System.out.println("***********");
        
        Arrays.fill(array, 3, 6, 50);//给数组array[3]~[6](不包括array[6])赋值50
        for (int i = 0, n = array.length; i < n; i++) {
            System.out.println(array[i]);
        }
    }
}
输出：
100
100
100
100
100
100
**********
100
100
100
50
50
50
```

那么我们改如何给二维数组赋初值呢？

```java
二维数组本质上看成每个空间存取一维数组的一维数组
for(int i = 0; i < R; i ++ ) Arrays.fill(a[i], -1);//这里传入的参数是一维数组a[i]
```

## 15.基本数据类型与String转换

**1、转化规则**

- String 转基本数据类型

```java
基本数据类型 变量 = 包装类.Parse基本数据类型(String);	// char类型不能这样转换，因为char是字节，String需要转成字符数组
```

- 基本数据类型转String

```java
String 变量 = 包装类.toString(基本数据类型);//等同于String.valueOf()
前者返回对象的字符串，后者返回对象的原始值，如果没有原始值则返回对象本身！
```

代码如下：

```java
// String 转 int
int a = Integer.parseInt("100");
System.out.println("a = " + a);
// int 转 String
String str1 = Integer.toString(100);
System.out.println("str1 = " + str1);
// String 转 double
double d = Double.parseDouble("100.00");
System.out.println("d = " + d);
// double 转 String
String str2 = Double.toString(100.00);
System.out.println("str2 = " + str2);
// char 转 String
String str3 = Character.toString('a');
System.out.println("str3 = " + str3);
// String 转 char数组
String s = "fafdfa1dd";
char[] c = s.toCharArray();
System.out.println("c = " + Arrays.toString(c));
12345678910111213141516171819
```

运行结果：

```java
"C:\Program Files\Java\jdk-11.0.9\bin\java.exe"
a = 100
str1 = 100
d = 100.0
str2 = 100.0
str3 = a
c = [f, a, f, d, f, a, 1, d, d]

Process finished with exit code 0
123456789
```

## 16.将集合转化成数组



```java
HashSet<Long> lists = new HashSet<>();//先定义一个set集合去重
Long[] arr = lists.toArray(new Long[0]);//然后将去重后的集合转化成数组arr存取
这里需要lists.toArray(new Long[0])传入集合的地址即new long[0]表示集合的头地址

```

