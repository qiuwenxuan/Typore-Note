## 1.集合基本概述

![image-20220310081330449](C:\Users\17377\AppData\Roaming\Typora\typora-user-images\image-20220310081330449.png)

## 2.时间复杂度与大O表示法

1. 大O表示法:去掉低阶项和常数项,取不带系数的高阶项(操作数为常数的时间复杂度为O(1))

| ![image-20211124221854603](C:\Users\17377\AppData\Roaming\Typora\typora-user-images\image-20211124221854603.png) |
| ------------------------------------------------------------ |

​	2.不同结构体的时间复杂度

1.for循环

| ![image-20211124223223148](C:\Users\17377\AppData\Roaming\Typora\typora-user-images\image-20211124223223148.png) |
| ------------------------------------------------------------ |

2.for的嵌套循环

| ![image-20211124224115536](C:\Users\17377\AppData\Roaming\Typora\typora-user-images\image-20211124224115536.png) |
| ------------------------------------------------------------ |

3.顺序语句

| ![image-20211124224219402](C:\Users\17377\AppData\Roaming\Typora\typora-user-images\image-20211124224219402.png) |
| ------------------------------------------------------------ |

4.if-else语句

| ![image-20211124224257354](C:\Users\17377\AppData\Roaming\Typora\typora-user-images\image-20211124224257354.png) |
| ------------------------------------------------------------ |

## 算法1:枚举

例://编写一个格式,程序输入一个数字n,使得a,b,c,d <= n形如a^3 = b^3+c^3+d^3 其中a,b,c,d均大于1且b<=c<=d.

```java
package day1125;

import java.util.Scanner;
//编写一个格式,程序输入一个数字n,使得a,b,c,d <= n形如a^3 = b^3+c^3+d^3 其中a,b,c,d均大于1且b<=c<=d.
public class Demo01meiju {
	public static void main(String[] args) {
		Scanner scan = new Scanner(System.in);
		System.out.println("请输入数字n:");
		int n = scan.nextInt();
		for(int a = 2; a <= n; a++) {
			for(int b = 2; b < a; b++) {
				for(int c = b; c < a; c++) {
					for(int d = c; d < a; d++) {
						if(a*a*a == b*b*b + c*c*c + d*d*d) {
							System.out.println("Cube = "+a+" Tripe = "+b+" "+c+" "+d);
						}
					}
				}
			}
		}
	}
}

```

枚举法求最大公因数和最小公倍数

```java
public static int gcd2(int a, int b) {//最大公因数 枚举法
		int min = Math.min(a, b);
		int result = 0;
		for(int i = 1; i <= min; i++) {
			if(a%i==0 && b%i==0) {
				result = i;
			}
		}
		return result;
	}

	public static int lcm2(int a,int b){//最小公倍数 枚举法
        int temp=0;
        if(a<=0||b==0){
            return -1;
        }
        temp=Math.max(a,b);
        while(temp%a!=0||temp%b!=0){
            temp++;
        }
        return temp;
    }
```

## 算法2:递归(recursion)

递归方法缓存的数据都储存在栈里面,且最后开辟的栈最开始运行.

递归的步骤:

​	1.找重复

​	2.找变化:变化的量应该作为边界

​	3.找边界:出口(限制条件)

1)求n的阶乘

```java
	public static int Factorial(int n) {
		if(n == 0) {
			return 1;
		}
		return n*Factorial(n-1);
	}
```

2)打印数字

```java
public static void f1(int i,int j){//变化的量:i必须作为参数
	if(i>=j)
	return;//程序边界
	System.out.println(i);
	f1(i+1,j);//重复条件
}
```

3)翻转字符串

```java
public class Reverse {
	public static void main(String[] args) {
		System.out.println(reverse("abcd",3));
	}
	public static String reverse(String src,int end) {//寻找变化的量end
		if(end==0) {//设置程序边界
			return ""+src.charAt(0);
			}
		return src.charAt(end)+reverse(src,end-1);//找重复
	}
}
运行结果:
	dcba
```

4)用递归实现斐波那契数列 

1、1、2、3、5、8、13、21、... F(1)=1, f(2)=1 ... F(N)=F(N-1)+F(N-2)

```java
public static int fiblibSum(int n){
		if (n==1 || n==2) 
			return 1;
		else
			return fiblibSum(n-1)+fiblibSum(n-2);
	}
```

即先算最后一个结果return 1; 再逐个把前面的结果fiblibSum(n-1)+fiblibSum(n-2)求出来.

5)求最大公因数

```java
public static int gcd(int a,int b){
	if(b==0)
	return a;
	gcd(b,a%b);
}
```

6）汉诺塔问题

```java
package lqbday1129;

public class HannuoTower {
	public static void main(String[] args) {
		printHannuoTower(3,"A","B","C");
	}
	static void printHannuoTower(int N, String from, String to, String help) {
		if(N==1) {
			System.out.println("move "+N+" from "+from+" to "+ to);
			return;
		}
		printHannuoTower(N-1,from,help,to);
		System.out.println("move "+N+" from "+from+" to "+to);
		printHannuoTower(N-1,help,to,from);	
		
	}
}
运行结果:
	move 1 from A to B
    move 2 from A to C
    move 1 from B to C
    move 3 from A to B
    move 1 from C to A
    move 2 from C to B
    move 1 from A to B

```

4种排序:冒泡排序,选择排序,插入排序,希尔排序

| ![image-20211130101142854](C:\Users\17377\AppData\Roaming\Typora\typora-user-images\image-20211130101142854.png) |
| ------------------------------------------------------------ |

1.冒泡排序

比较相邻两个数据,若较大的在前较小的在后则互换位置,交换完成之后继续向后移动,重复操作

```java
public static void bubbleSort2(int array[]) {
    int length = array.length;
    for (int i = length - 1; i >= 0; i--) {
        for (int j = i - 1; j >= 0; j--) {
            if (array[j] > array[i]) {
                swap(array, i, j);
            }
        }
    }
}
                                           
public static void swap(int[] A, int i, int j) {
    if (i != j) {
        A[i] ^= A[j];
        A[j] ^= A[i];
        A[i] ^= A[j];
    }
}
```

## 算法3：Math的方法

```java
Math.E                          //自然常数e=2.7182818284590452354
Math.abs(12.3);                 //12.3 返回该值的绝对值  
Math.abs(-12.3);                //12.3  

Math.copySign(1.23, -12.3);     //-1.23,返回第一个参数的量值和第二个参数的符号  
Math.copySign(-12.3, 1.23);     //12.3  

Math.signum(x);                 //如果x大于0则返回1.0，小于0则返回-1.0，等于0则返回0  
Math.signum(12.3);              //1.0  
Math.signum(-12.3);             //-1.0  
Math.signum(0);                 //0.0  


//指数  
Math.exp(x);                    //e的x次幂  
Math.expm1(x);                  //e的x次幂 - 1  

Math.scalb(x, y);               //x*(2的y次幂）  
Math.scalb(12.3, 3);            //12.3*2³  

//取整  
Math.ceil(12.3);   向上取整          //返回最近的且大于该值的整数13.0  
Math.ceil(-12.3);  向下取整          //-12.0  

Math.floor(12.3);               //返回最近的且小于该值的整数12.0  
Math.floor(-12.3);              //-13.0  

//x和y平方和的二次方根  
Math.hypot(x, y);               //√（x²+y²）  

//返回该值的二次方根  
Math.sqrt(x);                   //√(x) x的二次方根  
Math.sqrt(9);                   //3.0  
Math.sqrt(16);                  //4.0  

//返回该值的立方根  
Math.cbrt(27.0);                //3   
Math.cbrt(-125.0);              //-5  

//对数函数  
Math.log(e);                    //1 以e为底的对数  
Math.log10(100);                //10 以10为底的对数  
Math.log1p(x);                  //Ln（x+ 1）  

//返回较大值和较小值  
Math.max(x, y);                 //返回x、y中较大的那个数  
Math.min(x, y);                 //返回x、y中较小的那个数  

//返回x的y次幂  
Math.pow(x, y);                   
Math.pow(2, 3);                 //即2³ 即返回：8  

//随机返回[0,1)之间的无符号double值  
Math.random();                    

//返回最接近该值的整数,如果居中，则取偶数  
Math.rint(12.3);                //12.0   
Math.rint(-12.3);               //-12.0  
Math.rint(78.9);                //79.0  
Math.rint(-78.9);               //-79.0  
Math.rint(34.5);                //34.0  
Math.rint(35.5);                //36.0  

Math.round(12.3);               //与rint相似，返回值为long  

//三角函数  
Math.sin(α);                    //sin（α）的值  
Math.cos(α);                    //cos（α）的值  
Math.tan(α);                    //tan（α）的值  

//求角  
Math.asin(x/z);                 //返回角度值[-π/2，π/2]  arc sin（x/z）  
Math.acos(y/z);                 //返回角度值[0~π]   arc cos（y/z）  
Math.atan(y/x);                 //返回角度值[-π/2，π/2]  
Math.atan2(y-y0, x-x0);         //同上，返回经过点（x，y）与原点的的直线和经过点（x0，y0）与原点的直线之间所成的夹角  

Math.sinh(x);                   //双曲正弦函数sinh(x)=(exp(x) - exp(-x)) / 2.0;  
Math.cosh(x);                   //双曲余弦函数cosh(x)=(exp(x) + exp(-x)) / 2.0;  
Math.tanh(x);                   //tanh(x) = sinh(x) / cosh(x);  

//角度弧度互换  
Math.toDegrees(angrad);         //角度转换成弧度，返回：angrad * 180d / PI  

Math.toRadians(angdeg);         //弧度转换成角度，返回：angdeg / 180d * PI  
```

 
